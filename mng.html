<!DOCTYPE html>
<!-- saved from url=(0069)https://static.cmptch.com/v/lib/mng.html?1489559178#&#180#&#360#&#360 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <title></title>
    <script>
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {
'use strict';
var COMPILED = false;
var goog = goog || {};
goog.global = this;
goog.DEBUG = true;
goog.LOCALE = "en";
goog.provide = function(name) {
if(!COMPILED) {
if(goog.isProvided_(name)) {
throw Error('Namespace "' + name + '" already declared.');
}
delete goog.implicitNamespaces_[name];
var namespace = name;
while(namespace = namespace.substring(0, namespace.lastIndexOf("."))) {
if(goog.getObjectByName(namespace)) {
break
}
goog.implicitNamespaces_[namespace] = true
}
}
goog.exportPath_(name)
};
goog.setTestOnly = function(opt_message) {
if(COMPILED && !goog.DEBUG) {
opt_message = opt_message || "";
throw Error("Importing test-only code into non-debug environment" + opt_message ? ": " + opt_message : ".");
}
};
if(!COMPILED) {
goog.isProvided_ = function(name) {
return!goog.implicitNamespaces_[name] && !!goog.getObjectByName(name)
};
goog.implicitNamespaces_ = {}
}
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
var parts = name.split(".");
var cur = opt_objectToExportTo || goog.global;
if(!(parts[0] in cur) && cur.execScript) {
cur.execScript("var " + parts[0])
}
for(var part;parts.length && (part = parts.shift());) {
if(!parts.length && goog.isDef(opt_object)) {
cur[part] = opt_object
}else {
if(cur[part]) {
cur = cur[part]
}else {
cur = cur[part] = {}
}
}
}
};
goog.getObjectByName = function(name, opt_obj) {
var parts = name.split(".");
var cur = opt_obj || goog.global;
for(var part;part = parts.shift();) {
if(goog.isDefAndNotNull(cur[part])) {
cur = cur[part]
}else {
return null
}
}
return cur
};
goog.globalize = function(obj, opt_global) {
var global = opt_global || goog.global;
for(var x in obj) {
global[x] = obj[x]
}
};
goog.addDependency = function(relPath, provides, requires) {
if(!COMPILED) {
var provide, require;
var path = relPath.replace(/\\/g, "/");
var deps = goog.dependencies_;
for(var i = 0;provide = provides[i];i++) {
deps.nameToPath[provide] = path;
if(!(path in deps.pathToNames)) {
deps.pathToNames[path] = {}
}
deps.pathToNames[path][provide] = true
}
for(var j = 0;require = requires[j];j++) {
if(!(path in deps.requires)) {
deps.requires[path] = {}
}
deps.requires[path][require] = true
}
}
};
goog.ENABLE_DEBUG_LOADER = false;
goog.require = function(name) {
if(!COMPILED) {
if(goog.isProvided_(name)) {
return
}
if(goog.ENABLE_DEBUG_LOADER) {
var path = goog.getPathFromDeps_(name);
if(path) {
goog.included_[path] = true;
goog.writeScripts_();
return
}
}
var errorMessage = "goog.require could not find: " + name;
if(goog.global.console) {
goog.global.console["error"](errorMessage)
}
throw Error(errorMessage);
}
};
goog.basePath = "";
goog.global.CLOSURE_BASE_PATH;
goog.global.CLOSURE_NO_DEPS;
goog.global.CLOSURE_IMPORT_SCRIPT;
goog.nullFunction = function() {
};
goog.identityFunction = function(opt_returnValue, var_args) {
return opt_returnValue
};
goog.abstractMethod = function() {
throw Error("unimplemented abstract method");
};
goog.addSingletonGetter = function(ctor) {
ctor.getInstance = function() {
if(ctor.instance_) {
return ctor.instance_
}
if(goog.DEBUG) {
goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor
}
return ctor.instance_ = new ctor
}
};
goog.instantiatedSingletons_ = [];
if(!COMPILED && goog.ENABLE_DEBUG_LOADER) {
goog.included_ = {};
goog.dependencies_ = {pathToNames:{}, nameToPath:{}, requires:{}, visited:{}, written:{}};
goog.inHtmlDocument_ = function() {
var doc = goog.global.document;
return typeof doc != "undefined" && "write" in doc
};
goog.findBasePath_ = function() {
if(goog.global.CLOSURE_BASE_PATH) {
goog.basePath = goog.global.CLOSURE_BASE_PATH;
return
}else {
if(!goog.inHtmlDocument_()) {
return
}
}
var doc = goog.global.document;
var scripts = doc.getElementsByTagName("script");
for(var i = scripts.length - 1;i >= 0;--i) {
var src = scripts[i].src;
var qmark = src.lastIndexOf("?");
var l = qmark == -1 ? src.length : qmark;
if(src.substr(l - 7, 7) == "base.js") {
goog.basePath = src.substr(0, l - 7);
return
}
}
};
goog.importScript_ = function(src) {
var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
if(!goog.dependencies_.written[src] && importScript(src)) {
goog.dependencies_.written[src] = true
}
};
goog.writeScriptTag_ = function(src) {
if(goog.inHtmlDocument_()) {
var doc = goog.global.document;
doc.write('<script type="text/javascript" src="' + src + '"></' + "script>");
return true
}else {
return false
}
};
goog.writeScripts_ = function() {
var scripts = [];
var seenScript = {};
var deps = goog.dependencies_;
function visitNode(path) {
if(path in deps.written) {
return
}
if(path in deps.visited) {
if(!(path in seenScript)) {
seenScript[path] = true;
scripts.push(path)
}
return
}
deps.visited[path] = true;
if(path in deps.requires) {
for(var requireName in deps.requires[path]) {
if(!goog.isProvided_(requireName)) {
if(requireName in deps.nameToPath) {
visitNode(deps.nameToPath[requireName])
}else {
throw Error("Undefined nameToPath for " + requireName);
}
}
}
}
if(!(path in seenScript)) {
seenScript[path] = true;
scripts.push(path)
}
}
for(var path in goog.included_) {
if(!deps.written[path]) {
visitNode(path)
}
}
for(var i = 0;i < scripts.length;i++) {
if(scripts[i]) {
goog.importScript_(goog.basePath + scripts[i])
}else {
throw Error("Undefined script input");
}
}
};
goog.getPathFromDeps_ = function(rule) {
if(rule in goog.dependencies_.nameToPath) {
return goog.dependencies_.nameToPath[rule]
}else {
return null
}
};
goog.findBasePath_();
if(!goog.global.CLOSURE_NO_DEPS) {
goog.importScript_(goog.basePath + "deps.js")
}
}
goog.typeOf = function(value) {
var s = typeof value;
if(s == "object") {
if(value) {
if(value instanceof Array) {
return"array"
}else {
if(value instanceof Object) {
return s
}
}
var className = Object.prototype.toString.call((value));
if(className == "[object Window]") {
return"object"
}
if(className == "[object Array]" || typeof value.length == "number" && typeof value.splice != "undefined" && typeof value.propertyIsEnumerable != "undefined" && !value.propertyIsEnumerable("splice")) {
return"array"
}
if(className == "[object Function]" || typeof value.call != "undefined" && typeof value.propertyIsEnumerable != "undefined" && !value.propertyIsEnumerable("call")) {
return"function"
}
}else {
return"null"
}
}else {
if(s == "function" && typeof value.call == "undefined") {
return"object"
}
}
return s
};
goog.isDef = function(val) {
return val !== undefined
};
goog.isNull = function(val) {
return val === null
};
goog.isDefAndNotNull = function(val) {
return val != null
};
goog.isArray = function(val) {
return goog.typeOf(val) == "array"
};
goog.isArrayLike = function(val) {
var type = goog.typeOf(val);
return type == "array" || type == "object" && typeof val.length == "number"
};
goog.isDateLike = function(val) {
return goog.isObject(val) && typeof val.getFullYear == "function"
};
goog.isString = function(val) {
return typeof val == "string"
};
goog.isBoolean = function(val) {
return typeof val == "boolean"
};
goog.isNumber = function(val) {
return typeof val == "number"
};
goog.isFunction = function(val) {
return goog.typeOf(val) == "function"
};
goog.isObject = function(val) {
var type = typeof val;
return type == "object" && val != null || type == "function"
};
goog.getUid = function(obj) {
return obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_)
};
goog.removeUid = function(obj) {
if("removeAttribute" in obj) {
obj.removeAttribute(goog.UID_PROPERTY_)
}
try {
delete obj[goog.UID_PROPERTY_]
}catch(ex) {
}
};
goog.UID_PROPERTY_ = "closure_uid_" + Math.floor(Math.random() * 2147483648).toString(36);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function(obj) {
var type = goog.typeOf(obj);
if(type == "object" || type == "array") {
if(obj.clone) {
return obj.clone()
}
var clone = type == "array" ? [] : {};
for(var key in obj) {
clone[key] = goog.cloneObject(obj[key])
}
return clone
}
return obj
};
Object.prototype.clone;
goog.bindNative_ = function(fn, selfObj, var_args) {
return(fn.call.apply(fn.bind, arguments))
};
goog.bindJs_ = function(fn, selfObj, var_args) {
if(!fn) {
throw new Error;
}
if(arguments.length > 2) {
var boundArgs = Array.prototype.slice.call(arguments, 2);
return function() {
var newArgs = Array.prototype.slice.call(arguments);
Array.prototype.unshift.apply(newArgs, boundArgs);
return fn.apply(selfObj, newArgs)
}
}else {
return function() {
return fn.apply(selfObj, arguments)
}
}
};
goog.bind = function(fn, selfObj, var_args) {
if(Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1) {
goog.bind = goog.bindNative_
}else {
goog.bind = goog.bindJs_
}
return goog.bind.apply(null, arguments)
};
goog.partial = function(fn, var_args) {
var args = Array.prototype.slice.call(arguments, 1);
return function() {
var newArgs = Array.prototype.slice.call(arguments);
newArgs.unshift.apply(newArgs, args);
return fn.apply(this, newArgs)
}
};
goog.mixin = function(target, source) {
for(var x in source) {
target[x] = source[x]
}
};
goog.now = Date.now || function() {
return+new Date
};
goog.globalEval = function(script) {
if(goog.global.execScript) {
goog.global.execScript(script, "JavaScript")
}else {
if(goog.global.eval) {
if(goog.evalWorksForGlobals_ == null) {
goog.global.eval("var _et_ = 1;");
if(typeof goog.global["_et_"] != "undefined") {
delete goog.global["_et_"];
goog.evalWorksForGlobals_ = true
}else {
goog.evalWorksForGlobals_ = false
}
}
if(goog.evalWorksForGlobals_) {
goog.global.eval(script)
}else {
var doc = goog.global.document;
var scriptElt = doc.createElement("script");
scriptElt.type = "text/javascript";
scriptElt.defer = false;
scriptElt.appendChild(doc.createTextNode(script));
doc.body.appendChild(scriptElt);
doc.body.removeChild(scriptElt)
}
}else {
throw Error("goog.globalEval not available");
}
}
};
goog.evalWorksForGlobals_ = null;
goog.cssNameMapping_;
goog.cssNameMappingStyle_;
goog.getCssName = function(className, opt_modifier) {
var getMapping = function(cssName) {
return goog.cssNameMapping_[cssName] || cssName
};
var renameByParts = function(cssName) {
var parts = cssName.split("-");
var mapped = [];
for(var i = 0;i < parts.length;i++) {
mapped.push(getMapping(parts[i]))
}
return mapped.join("-")
};
var rename;
if(goog.cssNameMapping_) {
rename = goog.cssNameMappingStyle_ == "BY_WHOLE" ? getMapping : renameByParts
}else {
rename = function(a) {
return a
}
}
if(opt_modifier) {
return className + "-" + rename(opt_modifier)
}else {
return rename(className)
}
};
goog.setCssNameMapping = function(mapping, opt_style) {
goog.cssNameMapping_ = mapping;
goog.cssNameMappingStyle_ = opt_style
};
goog.global.CLOSURE_CSS_NAME_MAPPING;
if(!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING
}
goog.getMsg = function(str, opt_values) {
var values = opt_values || {};
for(var key in values) {
var value = ("" + values[key]).replace(/\$/g, "$$$$");
str = str.replace(new RegExp("\\{\\$" + key + "\\}", "gi"), value)
}
return str
};
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
goog.exportPath_(publicPath, object, opt_objectToExportTo)
};
goog.exportProperty = function(object, publicName, symbol) {
object[publicName] = symbol
};
goog.inherits = function(childCtor, parentCtor) {
function tempCtor() {
}
tempCtor.prototype = parentCtor.prototype;
childCtor.superClass_ = parentCtor.prototype;
childCtor.prototype = new tempCtor;
childCtor.prototype.constructor = childCtor
};
goog.base = function(me, opt_methodName, var_args) {
var caller = arguments.callee.caller;
if(caller.superClass_) {
return caller.superClass_.constructor.apply(me, Array.prototype.slice.call(arguments, 1))
}
var args = Array.prototype.slice.call(arguments, 2);
var foundCaller = false;
for(var ctor = me.constructor;ctor;ctor = ctor.superClass_ && ctor.superClass_.constructor) {
if(ctor.prototype[opt_methodName] === caller) {
foundCaller = true
}else {
if(foundCaller) {
return ctor.prototype[opt_methodName].apply(me, args)
}
}
}
if(me[opt_methodName] === caller) {
return me.constructor.prototype[opt_methodName].apply(me, args)
}else {
throw Error("goog.base called from a method of one name " + "to a method of a different name");
}
};
goog.scope = function(fn) {
fn.call(goog.global)
};
goog.provide("USE_TYPEDARRAY");
var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined" && typeof DataView !== "undefined";
goog.provide("Zlib.BitStream");
goog.require("USE_TYPEDARRAY");
goog.scope(function() {
Zlib.BitStream = function(buffer, bufferPosition) {
this.index = typeof bufferPosition === "number" ? bufferPosition : 0;
this.bitindex = 0;
this.buffer = buffer instanceof (USE_TYPEDARRAY ? Uint8Array : Array) ? buffer : new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.BitStream.DefaultBlockSize);
if(this.buffer.length * 2 <= this.index) {
throw new Error("invalid index");
}else {
if(this.buffer.length <= this.index) {
this.expandBuffer()
}
}
};
Zlib.BitStream.DefaultBlockSize = 32768;
Zlib.BitStream.prototype.expandBuffer = function() {
var oldbuf = this.buffer;
var i;
var il = oldbuf.length;
var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(il << 1);
if(USE_TYPEDARRAY) {
buffer.set(oldbuf)
}else {
for(i = 0;i < il;++i) {
buffer[i] = oldbuf[i]
}
}
return this.buffer = buffer
};
Zlib.BitStream.prototype.writeBits = function(number, n, reverse) {
var buffer = this.buffer;
var index = this.index;
var bitindex = this.bitindex;
var current = buffer[index];
var i;
function rev32_(n) {
return Zlib.BitStream.ReverseTable[n & 255] << 24 | Zlib.BitStream.ReverseTable[n >>> 8 & 255] << 16 | Zlib.BitStream.ReverseTable[n >>> 16 & 255] << 8 | Zlib.BitStream.ReverseTable[n >>> 24 & 255]
}
if(reverse && n > 1) {
number = n > 8 ? rev32_(number) >> 32 - n : Zlib.BitStream.ReverseTable[number] >> 8 - n
}
if(n + bitindex < 8) {
current = current << n | number;
bitindex += n
}else {
for(i = 0;i < n;++i) {
current = current << 1 | number >> n - i - 1 & 1;
if(++bitindex === 8) {
bitindex = 0;
buffer[index++] = Zlib.BitStream.ReverseTable[current];
current = 0;
if(index === buffer.length) {
buffer = this.expandBuffer()
}
}
}
}
buffer[index] = current;
this.buffer = buffer;
this.bitindex = bitindex;
this.index = index
};
Zlib.BitStream.prototype.finish = function() {
var buffer = this.buffer;
var index = this.index;
var output;
if(this.bitindex > 0) {
buffer[index] <<= 8 - this.bitindex;
buffer[index] = Zlib.BitStream.ReverseTable[buffer[index]];
index++
}
if(USE_TYPEDARRAY) {
output = buffer.subarray(0, index)
}else {
buffer.length = index;
output = buffer
}
return output
};
Zlib.BitStream.ReverseTable = function(table) {
return table
}(function() {
var table = new (USE_TYPEDARRAY ? Uint8Array : Array)(256);
var i;
for(i = 0;i < 256;++i) {
table[i] = function(n) {
var r = n;
var s = 7;
for(n >>>= 1;n;n >>>= 1) {
r <<= 1;
r |= n & 1;
--s
}
return(r << s & 255) >>> 0
}(i)
}
return table
}())
});
goog.provide("Zlib.Heap");
goog.require("USE_TYPEDARRAY");
goog.scope(function() {
Zlib.Heap = function(length) {
this.buffer = new (USE_TYPEDARRAY ? Uint16Array : Array)(length * 2);
this.length = 0
};
Zlib.Heap.prototype.getParent = function(index) {
return((index - 2) / 4 | 0) * 2
};
Zlib.Heap.prototype.getChild = function(index) {
return 2 * index + 2
};
Zlib.Heap.prototype.push = function(index, value) {
var current, parent, heap = this.buffer, swap;
current = this.length;
heap[this.length++] = value;
heap[this.length++] = index;
while(current > 0) {
parent = this.getParent(current);
if(heap[current] > heap[parent]) {
swap = heap[current];
heap[current] = heap[parent];
heap[parent] = swap;
swap = heap[current + 1];
heap[current + 1] = heap[parent + 1];
heap[parent + 1] = swap;
current = parent
}else {
break
}
}
return this.length
};
Zlib.Heap.prototype.pop = function() {
var index, value, heap = this.buffer, swap, current, parent;
value = heap[0];
index = heap[1];
this.length -= 2;
heap[0] = heap[this.length];
heap[1] = heap[this.length + 1];
parent = 0;
while(true) {
current = this.getChild(parent);
if(current >= this.length) {
break
}
if(current + 2 < this.length && heap[current + 2] > heap[current]) {
current += 2
}
if(heap[current] > heap[parent]) {
swap = heap[parent];
heap[parent] = heap[current];
heap[current] = swap;
swap = heap[parent + 1];
heap[parent + 1] = heap[current + 1];
heap[current + 1] = swap
}else {
break
}
parent = current
}
return{index:index, value:value, length:this.length}
}
});
goog.provide("Zlib.Huffman");
goog.require("USE_TYPEDARRAY");
goog.scope(function() {
Zlib.Huffman.buildHuffmanTable = function(lengths) {
var listSize = lengths.length;
var maxCodeLength = 0;
var minCodeLength = Number.POSITIVE_INFINITY;
var size;
var table;
var bitLength;
var code;
var skip;
var reversed;
var rtemp;
var i;
var il;
var j;
var value;
for(i = 0, il = listSize;i < il;++i) {
if(lengths[i] > maxCodeLength) {
maxCodeLength = lengths[i]
}
if(lengths[i] < minCodeLength) {
minCodeLength = lengths[i]
}
}
size = 1 << maxCodeLength;
table = new (USE_TYPEDARRAY ? Uint32Array : Array)(size);
for(bitLength = 1, code = 0, skip = 2;bitLength <= maxCodeLength;) {
for(i = 0;i < listSize;++i) {
if(lengths[i] === bitLength) {
for(reversed = 0, rtemp = code, j = 0;j < bitLength;++j) {
reversed = reversed << 1 | rtemp & 1;
rtemp >>= 1
}
value = bitLength << 16 | i;
for(j = reversed;j < size;j += skip) {
table[j] = value
}
++code
}
}
++bitLength;
code <<= 1;
skip <<= 1
}
return[table, maxCodeLength, minCodeLength]
}
});
goog.provide("Zlib.RawDeflate");
goog.require("USE_TYPEDARRAY");
goog.require("Zlib.BitStream");
goog.require("Zlib.Heap");
goog.scope(function() {
Zlib.RawDeflate = function(input, opt_params) {
this.compressionType = Zlib.RawDeflate.CompressionType.DYNAMIC;
this.lazy = 0;
this.freqsLitLen;
this.freqsDist;
this.input = USE_TYPEDARRAY && input instanceof Array ? new Uint8Array(input) : input;
this.output;
this.op = 0;
if(opt_params) {
if(opt_params["lazy"]) {
this.lazy = opt_params["lazy"]
}
if(typeof opt_params["compressionType"] === "number") {
this.compressionType = opt_params["compressionType"]
}
if(opt_params["outputBuffer"]) {
this.output = USE_TYPEDARRAY && opt_params["outputBuffer"] instanceof Array ? new Uint8Array(opt_params["outputBuffer"]) : opt_params["outputBuffer"]
}
if(typeof opt_params["outputIndex"] === "number") {
this.op = opt_params["outputIndex"]
}
}
if(!this.output) {
this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(32768)
}
};
Zlib.RawDeflate.CompressionType = {NONE:0, FIXED:1, DYNAMIC:2, RESERVED:3};
Zlib.RawDeflate.Lz77MinLength = 3;
Zlib.RawDeflate.Lz77MaxLength = 258;
Zlib.RawDeflate.WindowSize = 32768;
Zlib.RawDeflate.MaxCodeLength = 16;
Zlib.RawDeflate.HUFMAX = 286;
Zlib.RawDeflate.FixedHuffmanTable = function() {
var table = [], i;
for(i = 0;i < 288;i++) {
switch(true) {
case i <= 143:
table.push([i + 48, 8]);
break;
case i <= 255:
table.push([i - 144 + 400, 9]);
break;
case i <= 279:
table.push([i - 256 + 0, 7]);
break;
case i <= 287:
table.push([i - 280 + 192, 8]);
break;
default:
throw"invalid literal: " + i;
}
}
return table
}();
Zlib.RawDeflate.prototype.compress = function() {
var blockArray;
var position;
var length;
var input = this.input;
switch(this.compressionType) {
case Zlib.RawDeflate.CompressionType.NONE:
for(position = 0, length = input.length;position < length;) {
blockArray = USE_TYPEDARRAY ? input.subarray(position, position + 65535) : input.slice(position, position + 65535);
position += blockArray.length;
this.makeNocompressBlock(blockArray, position === length)
}
break;
case Zlib.RawDeflate.CompressionType.FIXED:
this.output = this.makeFixedHuffmanBlock(input, true);
this.op = this.output.length;
break;
case Zlib.RawDeflate.CompressionType.DYNAMIC:
this.output = this.makeDynamicHuffmanBlock(input, true);
this.op = this.output.length;
break;
default:
throw"invalid compression type";
}
return this.output
};
Zlib.RawDeflate.prototype.makeNocompressBlock = function(blockArray, isFinalBlock) {
var bfinal;
var btype;
var len;
var nlen;
var i;
var il;
var output = this.output;
var op = this.op;
if(USE_TYPEDARRAY) {
output = new Uint8Array(this.output.buffer);
while(output.length <= op + blockArray.length + 5) {
output = new Uint8Array(output.length << 1)
}
output.set(this.output)
}
bfinal = isFinalBlock ? 1 : 0;
btype = Zlib.RawDeflate.CompressionType.NONE;
output[op++] = bfinal | btype << 1;
len = blockArray.length;
nlen = ~len + 65536 & 65535;
output[op++] = len & 255;
output[op++] = len >>> 8 & 255;
output[op++] = nlen & 255;
output[op++] = nlen >>> 8 & 255;
if(USE_TYPEDARRAY) {
output.set(blockArray, op);
op += blockArray.length;
output = output.subarray(0, op)
}else {
for(i = 0, il = blockArray.length;i < il;++i) {
output[op++] = blockArray[i]
}
output.length = op
}
this.op = op;
this.output = output;
return output
};
Zlib.RawDeflate.prototype.makeFixedHuffmanBlock = function(blockArray, isFinalBlock) {
var stream = new Zlib.BitStream(USE_TYPEDARRAY ? new Uint8Array(this.output.buffer) : this.output, this.op);
var bfinal;
var btype;
var data;
bfinal = isFinalBlock ? 1 : 0;
btype = Zlib.RawDeflate.CompressionType.FIXED;
stream.writeBits(bfinal, 1, true);
stream.writeBits(btype, 2, true);
data = this.lz77(blockArray);
this.fixedHuffman(data, stream);
return stream.finish()
};
Zlib.RawDeflate.prototype.makeDynamicHuffmanBlock = function(blockArray, isFinalBlock) {
var stream = new Zlib.BitStream(USE_TYPEDARRAY ? new Uint8Array(this.output.buffer) : this.output, this.op);
var bfinal;
var btype;
var data;
var hlit;
var hdist;
var hclen;
var hclenOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var litLenLengths;
var litLenCodes;
var distLengths;
var distCodes;
var treeSymbols;
var treeLengths;
var transLengths = new Array(19);
var treeCodes;
var code;
var bitlen;
var i;
var il;
bfinal = isFinalBlock ? 1 : 0;
btype = Zlib.RawDeflate.CompressionType.DYNAMIC;
stream.writeBits(bfinal, 1, true);
stream.writeBits(btype, 2, true);
data = this.lz77(blockArray);
litLenLengths = this.getLengths_(this.freqsLitLen, 15);
litLenCodes = this.getCodesFromLengths_(litLenLengths);
distLengths = this.getLengths_(this.freqsDist, 7);
distCodes = this.getCodesFromLengths_(distLengths);
for(hlit = 286;hlit > 257 && litLenLengths[hlit - 1] === 0;hlit--) {
}
for(hdist = 30;hdist > 1 && distLengths[hdist - 1] === 0;hdist--) {
}
treeSymbols = this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
treeLengths = this.getLengths_(treeSymbols.freqs, 7);
for(i = 0;i < 19;i++) {
transLengths[i] = treeLengths[hclenOrder[i]]
}
for(hclen = 19;hclen > 4 && transLengths[hclen - 1] === 0;hclen--) {
}
treeCodes = this.getCodesFromLengths_(treeLengths);
stream.writeBits(hlit - 257, 5, true);
stream.writeBits(hdist - 1, 5, true);
stream.writeBits(hclen - 4, 4, true);
for(i = 0;i < hclen;i++) {
stream.writeBits(transLengths[i], 3, true)
}
for(i = 0, il = treeSymbols.codes.length;i < il;i++) {
code = treeSymbols.codes[i];
stream.writeBits(treeCodes[code], treeLengths[code], true);
if(code >= 16) {
i++;
switch(code) {
case 16:
bitlen = 2;
break;
case 17:
bitlen = 3;
break;
case 18:
bitlen = 7;
break;
default:
throw"invalid code: " + code;
}
stream.writeBits(treeSymbols.codes[i], bitlen, true)
}
}
this.dynamicHuffman(data, [litLenCodes, litLenLengths], [distCodes, distLengths], stream);
return stream.finish()
};
Zlib.RawDeflate.prototype.dynamicHuffman = function(dataArray, litLen, dist, stream) {
var index;
var length;
var literal;
var code;
var litLenCodes;
var litLenLengths;
var distCodes;
var distLengths;
litLenCodes = litLen[0];
litLenLengths = litLen[1];
distCodes = dist[0];
distLengths = dist[1];
for(index = 0, length = dataArray.length;index < length;++index) {
literal = dataArray[index];
stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);
if(literal > 256) {
stream.writeBits(dataArray[++index], dataArray[++index], true);
code = dataArray[++index];
stream.writeBits(distCodes[code], distLengths[code], true);
stream.writeBits(dataArray[++index], dataArray[++index], true)
}else {
if(literal === 256) {
break
}
}
}
return stream
};
Zlib.RawDeflate.prototype.fixedHuffman = function(dataArray, stream) {
var index;
var length;
var literal;
for(index = 0, length = dataArray.length;index < length;index++) {
literal = dataArray[index];
Zlib.BitStream.prototype.writeBits.apply(stream, Zlib.RawDeflate.FixedHuffmanTable[literal]);
if(literal > 256) {
stream.writeBits(dataArray[++index], dataArray[++index], true);
stream.writeBits(dataArray[++index], 5);
stream.writeBits(dataArray[++index], dataArray[++index], true)
}else {
if(literal === 256) {
break
}
}
}
return stream
};
Zlib.RawDeflate.Lz77Match = function(length, backwardDistance) {
this.length = length;
this.backwardDistance = backwardDistance
};
Zlib.RawDeflate.Lz77Match.LengthCodeTable = function(table) {
return USE_TYPEDARRAY ? new Uint32Array(table) : table
}(function() {
var table = [];
var i;
var c;
for(i = 3;i <= 258;i++) {
c = code(i);
table[i] = c[2] << 24 | c[1] << 16 | c[0]
}
function code(length) {
switch(true) {
case length === 3:
return[257, length - 3, 0];
break;
case length === 4:
return[258, length - 4, 0];
break;
case length === 5:
return[259, length - 5, 0];
break;
case length === 6:
return[260, length - 6, 0];
break;
case length === 7:
return[261, length - 7, 0];
break;
case length === 8:
return[262, length - 8, 0];
break;
case length === 9:
return[263, length - 9, 0];
break;
case length === 10:
return[264, length - 10, 0];
break;
case length <= 12:
return[265, length - 11, 1];
break;
case length <= 14:
return[266, length - 13, 1];
break;
case length <= 16:
return[267, length - 15, 1];
break;
case length <= 18:
return[268, length - 17, 1];
break;
case length <= 22:
return[269, length - 19, 2];
break;
case length <= 26:
return[270, length - 23, 2];
break;
case length <= 30:
return[271, length - 27, 2];
break;
case length <= 34:
return[272, length - 31, 2];
break;
case length <= 42:
return[273, length - 35, 3];
break;
case length <= 50:
return[274, length - 43, 3];
break;
case length <= 58:
return[275, length - 51, 3];
break;
case length <= 66:
return[276, length - 59, 3];
break;
case length <= 82:
return[277, length - 67, 4];
break;
case length <= 98:
return[278, length - 83, 4];
break;
case length <= 114:
return[279, length - 99, 4];
break;
case length <= 130:
return[280, length - 115, 4];
break;
case length <= 162:
return[281, length - 131, 5];
break;
case length <= 194:
return[282, length - 163, 5];
break;
case length <= 226:
return[283, length - 195, 5];
break;
case length <= 257:
return[284, length - 227, 5];
break;
case length === 258:
return[285, length - 258, 0];
break;
default:
throw"invalid length: " + length;
}
}
return table
}());
Zlib.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function(dist) {
var r;
switch(true) {
case dist === 1:
r = [0, dist - 1, 0];
break;
case dist === 2:
r = [1, dist - 2, 0];
break;
case dist === 3:
r = [2, dist - 3, 0];
break;
case dist === 4:
r = [3, dist - 4, 0];
break;
case dist <= 6:
r = [4, dist - 5, 1];
break;
case dist <= 8:
r = [5, dist - 7, 1];
break;
case dist <= 12:
r = [6, dist - 9, 2];
break;
case dist <= 16:
r = [7, dist - 13, 2];
break;
case dist <= 24:
r = [8, dist - 17, 3];
break;
case dist <= 32:
r = [9, dist - 25, 3];
break;
case dist <= 48:
r = [10, dist - 33, 4];
break;
case dist <= 64:
r = [11, dist - 49, 4];
break;
case dist <= 96:
r = [12, dist - 65, 5];
break;
case dist <= 128:
r = [13, dist - 97, 5];
break;
case dist <= 192:
r = [14, dist - 129, 6];
break;
case dist <= 256:
r = [15, dist - 193, 6];
break;
case dist <= 384:
r = [16, dist - 257, 7];
break;
case dist <= 512:
r = [17, dist - 385, 7];
break;
case dist <= 768:
r = [18, dist - 513, 8];
break;
case dist <= 1024:
r = [19, dist - 769, 8];
break;
case dist <= 1536:
r = [20, dist - 1025, 9];
break;
case dist <= 2048:
r = [21, dist - 1537, 9];
break;
case dist <= 3072:
r = [22, dist - 2049, 10];
break;
case dist <= 4096:
r = [23, dist - 3073, 10];
break;
case dist <= 6144:
r = [24, dist - 4097, 11];
break;
case dist <= 8192:
r = [25, dist - 6145, 11];
break;
case dist <= 12288:
r = [26, dist - 8193, 12];
break;
case dist <= 16384:
r = [27, dist - 12289, 12];
break;
case dist <= 24576:
r = [28, dist - 16385, 13];
break;
case dist <= 32768:
r = [29, dist - 24577, 13];
break;
default:
throw"invalid distance";
}
return r
};
Zlib.RawDeflate.Lz77Match.prototype.toLz77Array = function() {
var length = this.length;
var dist = this.backwardDistance;
var codeArray = [];
var pos = 0;
var code;
code = Zlib.RawDeflate.Lz77Match.LengthCodeTable[length];
codeArray[pos++] = code & 65535;
codeArray[pos++] = code >> 16 & 255;
codeArray[pos++] = code >> 24;
code = this.getDistanceCode_(dist);
codeArray[pos++] = code[0];
codeArray[pos++] = code[1];
codeArray[pos++] = code[2];
return codeArray
};
Zlib.RawDeflate.prototype.lz77 = function(dataArray) {
var position;
var length;
var i;
var il;
var matchKey;
var table = {};
var windowSize = Zlib.RawDeflate.WindowSize;
var matchList;
var longestMatch;
var prevMatch;
var lz77buf = USE_TYPEDARRAY ? new Uint16Array(dataArray.length * 2) : [];
var pos = 0;
var skipLength = 0;
var freqsLitLen = new (USE_TYPEDARRAY ? Uint32Array : Array)(286);
var freqsDist = new (USE_TYPEDARRAY ? Uint32Array : Array)(30);
var lazy = this.lazy;
var tmp;
if(!USE_TYPEDARRAY) {
for(i = 0;i <= 285;) {
freqsLitLen[i++] = 0
}
for(i = 0;i <= 29;) {
freqsDist[i++] = 0
}
}
freqsLitLen[256] = 1;
function writeMatch(match, offset) {
var lz77Array = match.toLz77Array();
var i;
var il;
for(i = 0, il = lz77Array.length;i < il;++i) {
lz77buf[pos++] = lz77Array[i]
}
freqsLitLen[lz77Array[0]]++;
freqsDist[lz77Array[3]]++;
skipLength = match.length + offset - 1;
prevMatch = null
}
for(position = 0, length = dataArray.length;position < length;++position) {
for(matchKey = 0, i = 0, il = Zlib.RawDeflate.Lz77MinLength;i < il;++i) {
if(position + i === length) {
break
}
matchKey = matchKey << 8 | dataArray[position + i]
}
if(table[matchKey] === void 0) {
table[matchKey] = []
}
matchList = table[matchKey];
if(skipLength-- > 0) {
matchList.push(position);
continue
}
while(matchList.length > 0 && position - matchList[0] > windowSize) {
matchList.shift()
}
if(position + Zlib.RawDeflate.Lz77MinLength >= length) {
if(prevMatch) {
writeMatch(prevMatch, -1)
}
for(i = 0, il = length - position;i < il;++i) {
tmp = dataArray[position + i];
lz77buf[pos++] = tmp;
++freqsLitLen[tmp]
}
break
}
if(matchList.length > 0) {
longestMatch = this.searchLongestMatch_(dataArray, position, matchList);
if(prevMatch) {
if(prevMatch.length < longestMatch.length) {
tmp = dataArray[position - 1];
lz77buf[pos++] = tmp;
++freqsLitLen[tmp];
writeMatch(longestMatch, 0)
}else {
writeMatch(prevMatch, -1)
}
}else {
if(longestMatch.length < lazy) {
prevMatch = longestMatch
}else {
writeMatch(longestMatch, 0)
}
}
}else {
if(prevMatch) {
writeMatch(prevMatch, -1)
}else {
tmp = dataArray[position];
lz77buf[pos++] = tmp;
++freqsLitLen[tmp]
}
}
matchList.push(position)
}
lz77buf[pos++] = 256;
freqsLitLen[256]++;
this.freqsLitLen = freqsLitLen;
this.freqsDist = freqsDist;
return(USE_TYPEDARRAY ? lz77buf.subarray(0, pos) : lz77buf)
};
Zlib.RawDeflate.prototype.searchLongestMatch_ = function(data, position, matchList) {
var match, currentMatch, matchMax = 0, matchLength, i, j, l, dl = data.length;
permatch:for(i = 0, l = matchList.length;i < l;i++) {
match = matchList[l - i - 1];
matchLength = Zlib.RawDeflate.Lz77MinLength;
if(matchMax > Zlib.RawDeflate.Lz77MinLength) {
for(j = matchMax;j > Zlib.RawDeflate.Lz77MinLength;j--) {
if(data[match + j - 1] !== data[position + j - 1]) {
continue permatch
}
}
matchLength = matchMax
}
while(matchLength < Zlib.RawDeflate.Lz77MaxLength && position + matchLength < dl && data[match + matchLength] === data[position + matchLength]) {
++matchLength
}
if(matchLength > matchMax) {
currentMatch = match;
matchMax = matchLength
}
if(matchLength === Zlib.RawDeflate.Lz77MaxLength) {
break
}
}
return new Zlib.RawDeflate.Lz77Match(matchMax, position - currentMatch)
};
Zlib.RawDeflate.prototype.getTreeSymbols_ = function(hlit, litlenLengths, hdist, distLengths) {
var src = new (USE_TYPEDARRAY ? Uint32Array : Array)(hlit + hdist), i, j, runLength, l, result = new (USE_TYPEDARRAY ? Uint32Array : Array)(286 + 30), nResult, rpt, freqs = new (USE_TYPEDARRAY ? Uint8Array : Array)(19);
j = 0;
for(i = 0;i < hlit;i++) {
src[j++] = litlenLengths[i]
}
for(i = 0;i < hdist;i++) {
src[j++] = distLengths[i]
}
if(!USE_TYPEDARRAY) {
for(i = 0, l = freqs.length;i < l;++i) {
freqs[i] = 0
}
}
nResult = 0;
for(i = 0, l = src.length;i < l;i += j) {
for(j = 1;i + j < l && src[i + j] === src[i];++j) {
}
runLength = j;
if(src[i] === 0) {
if(runLength < 3) {
while(runLength-- > 0) {
result[nResult++] = 0;
freqs[0]++
}
}else {
while(runLength > 0) {
rpt = runLength < 138 ? runLength : 138;
if(rpt > runLength - 3 && rpt < runLength) {
rpt = runLength - 3
}
if(rpt <= 10) {
result[nResult++] = 17;
result[nResult++] = rpt - 3;
freqs[17]++
}else {
result[nResult++] = 18;
result[nResult++] = rpt - 11;
freqs[18]++
}
runLength -= rpt
}
}
}else {
result[nResult++] = src[i];
freqs[src[i]]++;
runLength--;
if(runLength < 3) {
while(runLength-- > 0) {
result[nResult++] = src[i];
freqs[src[i]]++
}
}else {
while(runLength > 0) {
rpt = runLength < 6 ? runLength : 6;
if(rpt > runLength - 3 && rpt < runLength) {
rpt = runLength - 3
}
result[nResult++] = 16;
result[nResult++] = rpt - 3;
freqs[16]++;
runLength -= rpt
}
}
}
}
return{codes:USE_TYPEDARRAY ? result.subarray(0, nResult) : result.slice(0, nResult), freqs:freqs}
};
Zlib.RawDeflate.prototype.getLengths_ = function(freqs, limit) {
var nSymbols = freqs.length;
var heap = new Zlib.Heap(2 * Zlib.RawDeflate.HUFMAX);
var length = new (USE_TYPEDARRAY ? Uint8Array : Array)(nSymbols);
var nodes;
var values;
var codeLength;
var i;
var il;
if(!USE_TYPEDARRAY) {
for(i = 0;i < nSymbols;i++) {
length[i] = 0
}
}
for(i = 0;i < nSymbols;++i) {
if(freqs[i] > 0) {
heap.push(i, freqs[i])
}
}
nodes = new Array(heap.length / 2);
values = new (USE_TYPEDARRAY ? Uint32Array : Array)(heap.length / 2);
if(nodes.length === 1) {
length[heap.pop().index] = 1;
return length
}
for(i = 0, il = heap.length / 2;i < il;++i) {
nodes[i] = heap.pop();
values[i] = nodes[i].value
}
codeLength = this.reversePackageMerge_(values, values.length, limit);
for(i = 0, il = nodes.length;i < il;++i) {
length[nodes[i].index] = codeLength[i]
}
return length
};
Zlib.RawDeflate.prototype.reversePackageMerge_ = function(freqs, symbols, limit) {
var minimumCost = new (USE_TYPEDARRAY ? Uint16Array : Array)(limit);
var flag = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);
var codeLength = new (USE_TYPEDARRAY ? Uint8Array : Array)(symbols);
var value = new Array(limit);
var type = new Array(limit);
var currentPosition = new Array(limit);
var excess = (1 << limit) - symbols;
var half = 1 << limit - 1;
var i;
var j;
var t;
var weight;
var next;
function takePackage(j) {
var x = type[j][currentPosition[j]];
if(x === symbols) {
takePackage(j + 1);
takePackage(j + 1)
}else {
--codeLength[x]
}
++currentPosition[j]
}
minimumCost[limit - 1] = symbols;
for(j = 0;j < limit;++j) {
if(excess < half) {
flag[j] = 0
}else {
flag[j] = 1;
excess -= half
}
excess <<= 1;
minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols
}
minimumCost[0] = flag[0];
value[0] = new Array(minimumCost[0]);
type[0] = new Array(minimumCost[0]);
for(j = 1;j < limit;++j) {
if(minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {
minimumCost[j] = 2 * minimumCost[j - 1] + flag[j]
}
value[j] = new Array(minimumCost[j]);
type[j] = new Array(minimumCost[j])
}
for(i = 0;i < symbols;++i) {
codeLength[i] = limit
}
for(t = 0;t < minimumCost[limit - 1];++t) {
value[limit - 1][t] = freqs[t];
type[limit - 1][t] = t
}
for(i = 0;i < limit;++i) {
currentPosition[i] = 0
}
if(flag[limit - 1] === 1) {
--codeLength[0];
++currentPosition[limit - 1]
}
for(j = limit - 2;j >= 0;--j) {
i = 0;
weight = 0;
next = currentPosition[j + 1];
for(t = 0;t < minimumCost[j];t++) {
weight = value[j + 1][next] + value[j + 1][next + 1];
if(weight > freqs[i]) {
value[j][t] = weight;
type[j][t] = symbols;
next += 2
}else {
value[j][t] = freqs[i];
type[j][t] = i;
++i
}
}
currentPosition[j] = 0;
if(flag[j] === 1) {
takePackage(j)
}
}
return codeLength
};
Zlib.RawDeflate.prototype.getCodesFromLengths_ = function(lengths) {
var codes = new (USE_TYPEDARRAY ? Uint16Array : Array)(lengths.length), count = [], startCode = [], code = 0, i, il, j, m;
for(i = 0, il = lengths.length;i < il;i++) {
count[lengths[i]] = (count[lengths[i]] | 0) + 1
}
for(i = 1, il = Zlib.RawDeflate.MaxCodeLength;i <= il;i++) {
startCode[i] = code;
code += count[i] | 0;
code <<= 1
}
for(i = 0, il = lengths.length;i < il;i++) {
code = startCode[lengths[i]];
startCode[lengths[i]] += 1;
codes[i] = 0;
for(j = 0, m = lengths[i];j < m;j++) {
codes[i] = codes[i] << 1 | code & 1;
code >>>= 1
}
}
return codes
}
});
goog.provide("Zlib.RawInflate");
goog.require("USE_TYPEDARRAY");
goog.require("Zlib.Huffman");
var ZLIB_RAW_INFLATE_BUFFER_SIZE = 32768;
goog.scope(function() {
var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;
Zlib.RawInflate = function(input, opt_params) {
this.buffer;
this.blocks = [];
this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;
this.totalpos = 0;
this.ip = 0;
this.bitsbuf = 0;
this.bitsbuflen = 0;
this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;
this.output;
this.op;
this.bfinal = false;
this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;
this.resize = false;
this.prev;
if(opt_params || !(opt_params = {})) {
if(opt_params["index"]) {
this.ip = opt_params["index"]
}
if(opt_params["bufferSize"]) {
this.bufferSize = opt_params["bufferSize"]
}
if(opt_params["bufferType"]) {
this.bufferType = opt_params["bufferType"]
}
if(opt_params["resize"]) {
this.resize = opt_params["resize"]
}
}
switch(this.bufferType) {
case Zlib.RawInflate.BufferType.BLOCK:
this.op = Zlib.RawInflate.MaxBackwardLength;
this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflate.MaxBackwardLength + this.bufferSize + Zlib.RawInflate.MaxCopyLength);
break;
case Zlib.RawInflate.BufferType.ADAPTIVE:
this.op = 0;
this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);
this.expandBuffer = this.expandBufferAdaptive;
this.concatBuffer = this.concatBufferDynamic;
this.decodeHuffman = this.decodeHuffmanAdaptive;
break;
default:
throw new Error("invalid inflate mode");
}
};
Zlib.RawInflate.BufferType = {BLOCK:0, ADAPTIVE:1};
Zlib.RawInflate.prototype.decompress = function() {
while(!this.bfinal) {
this.parseBlock()
}
return this.concatBuffer()
};
Zlib.RawInflate.MaxBackwardLength = 32768;
Zlib.RawInflate.MaxCopyLength = 258;
Zlib.RawInflate.Order = function(table) {
return USE_TYPEDARRAY ? new Uint16Array(table) : table
}([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
Zlib.RawInflate.LengthCodeTable = function(table) {
return USE_TYPEDARRAY ? new Uint16Array(table) : table
}([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258]);
Zlib.RawInflate.LengthExtraTable = function(table) {
return USE_TYPEDARRAY ? new Uint8Array(table) : table
}([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
Zlib.RawInflate.DistCodeTable = function(table) {
return USE_TYPEDARRAY ? new Uint16Array(table) : table
}([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]);
Zlib.RawInflate.DistExtraTable = function(table) {
return USE_TYPEDARRAY ? new Uint8Array(table) : table
}([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
Zlib.RawInflate.FixedLiteralLengthTable = function(table) {
return table
}(function() {
var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);
var i, il;
for(i = 0, il = lengths.length;i < il;++i) {
lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8
}
return buildHuffmanTable(lengths)
}());
Zlib.RawInflate.FixedDistanceTable = function(table) {
return table
}(function() {
var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);
var i, il;
for(i = 0, il = lengths.length;i < il;++i) {
lengths[i] = 5
}
return buildHuffmanTable(lengths)
}());
Zlib.RawInflate.prototype.parseBlock = function() {
var hdr = this.readBits(3);
if(hdr & 1) {
this.bfinal = true
}
hdr >>>= 1;
switch(hdr) {
case 0:
this.parseUncompressedBlock();
break;
case 1:
this.parseFixedHuffmanBlock();
break;
case 2:
this.parseDynamicHuffmanBlock();
break;
default:
throw new Error("unknown BTYPE: " + hdr);
}
};
Zlib.RawInflate.prototype.readBits = function(length) {
var bitsbuf = this.bitsbuf;
var bitsbuflen = this.bitsbuflen;
var input = this.input;
var ip = this.ip;
var inputLength = input.length;
var octet;
while(bitsbuflen < length) {
if(ip >= inputLength) {
throw new Error("input buffer is broken");
}
bitsbuf |= input[ip++] << bitsbuflen;
bitsbuflen += 8
}
octet = bitsbuf & (1 << length) - 1;
bitsbuf >>>= length;
bitsbuflen -= length;
this.bitsbuf = bitsbuf;
this.bitsbuflen = bitsbuflen;
this.ip = ip;
return octet
};
Zlib.RawInflate.prototype.readCodeByTable = function(table) {
var bitsbuf = this.bitsbuf;
var bitsbuflen = this.bitsbuflen;
var input = this.input;
var ip = this.ip;
var inputLength = input.length;
var codeTable = table[0];
var maxCodeLength = table[1];
var codeWithLength;
var codeLength;
while(bitsbuflen < maxCodeLength) {
if(ip >= inputLength) {
break
}
bitsbuf |= input[ip++] << bitsbuflen;
bitsbuflen += 8
}
codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
codeLength = codeWithLength >>> 16;
this.bitsbuf = bitsbuf >> codeLength;
this.bitsbuflen = bitsbuflen - codeLength;
this.ip = ip;
return codeWithLength & 65535
};
Zlib.RawInflate.prototype.parseUncompressedBlock = function() {
var input = this.input;
var ip = this.ip;
var output = this.output;
var op = this.op;
var inputLength = input.length;
var len;
var nlen;
var olength = output.length;
var preCopy;
this.bitsbuf = 0;
this.bitsbuflen = 0;
if(ip + 1 >= inputLength) {
throw new Error("invalid uncompressed block header: LEN");
}
len = input[ip++] | input[ip++] << 8;
if(ip + 1 >= inputLength) {
throw new Error("invalid uncompressed block header: NLEN");
}
nlen = input[ip++] | input[ip++] << 8;
if(len === ~nlen) {
throw new Error("invalid uncompressed block header: length verify");
}
if(ip + len > input.length) {
throw new Error("input buffer is broken");
}
switch(this.bufferType) {
case Zlib.RawInflate.BufferType.BLOCK:
while(op + len > output.length) {
preCopy = olength - op;
len -= preCopy;
if(USE_TYPEDARRAY) {
output.set(input.subarray(ip, ip + preCopy), op);
op += preCopy;
ip += preCopy
}else {
while(preCopy--) {
output[op++] = input[ip++]
}
}
this.op = op;
output = this.expandBuffer();
op = this.op
}
break;
case Zlib.RawInflate.BufferType.ADAPTIVE:
while(op + len > output.length) {
output = this.expandBuffer({fixRatio:2})
}
break;
default:
throw new Error("invalid inflate mode");
}
if(USE_TYPEDARRAY) {
output.set(input.subarray(ip, ip + len), op);
op += len;
ip += len
}else {
while(len--) {
output[op++] = input[ip++]
}
}
this.ip = ip;
this.op = op;
this.output = output
};
Zlib.RawInflate.prototype.parseFixedHuffmanBlock = function() {
this.decodeHuffman(Zlib.RawInflate.FixedLiteralLengthTable, Zlib.RawInflate.FixedDistanceTable)
};
Zlib.RawInflate.prototype.parseDynamicHuffmanBlock = function() {
var hlit = this.readBits(5) + 257;
var hdist = this.readBits(5) + 1;
var hclen = this.readBits(4) + 4;
var codeLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.RawInflate.Order.length);
var codeLengthsTable;
var litlenLengths;
var distLengths;
var i;
for(i = 0;i < hclen;++i) {
codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3)
}
if(!USE_TYPEDARRAY) {
for(i = hclen, hclen = codeLengths.length;i < hclen;++i) {
codeLengths[Zlib.RawInflate.Order[i]] = 0
}
}
codeLengthsTable = buildHuffmanTable(codeLengths);
function decode(num, table, lengths) {
var code;
var prev = this.prev;
var repeat;
var i;
for(i = 0;i < num;) {
code = this.readCodeByTable(table);
switch(code) {
case 16:
repeat = 3 + this.readBits(2);
while(repeat--) {
lengths[i++] = prev
}
break;
case 17:
repeat = 3 + this.readBits(3);
while(repeat--) {
lengths[i++] = 0
}
prev = 0;
break;
case 18:
repeat = 11 + this.readBits(7);
while(repeat--) {
lengths[i++] = 0
}
prev = 0;
break;
default:
lengths[i++] = code;
prev = code;
break
}
}
this.prev = prev;
return lengths
}
litlenLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit);
distLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hdist);
this.prev = 0;
this.decodeHuffman(buildHuffmanTable(decode.call(this, hlit, codeLengthsTable, litlenLengths)), buildHuffmanTable(decode.call(this, hdist, codeLengthsTable, distLengths)))
};
Zlib.RawInflate.prototype.decodeHuffman = function(litlen, dist) {
var output = this.output;
var op = this.op;
this.currentLitlenTable = litlen;
var olength = output.length - Zlib.RawInflate.MaxCopyLength;
var code;
var ti;
var codeDist;
var codeLength;
while((code = this.readCodeByTable(litlen)) !== 256) {
if(code < 256) {
if(op >= olength) {
this.op = op;
output = this.expandBuffer();
op = this.op
}
output[op++] = code;
continue
}
ti = code - 257;
codeLength = Zlib.RawInflate.LengthCodeTable[ti];
if(Zlib.RawInflate.LengthExtraTable[ti] > 0) {
codeLength += this.readBits(Zlib.RawInflate.LengthExtraTable[ti])
}
code = this.readCodeByTable(dist);
codeDist = Zlib.RawInflate.DistCodeTable[code];
if(Zlib.RawInflate.DistExtraTable[code] > 0) {
codeDist += this.readBits(Zlib.RawInflate.DistExtraTable[code])
}
if(op >= olength) {
this.op = op;
output = this.expandBuffer();
op = this.op
}
while(codeLength--) {
output[op] = output[op++ - codeDist]
}
}
while(this.bitsbuflen >= 8) {
this.bitsbuflen -= 8;
this.ip--
}
this.op = op
};
Zlib.RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {
var output = this.output;
var op = this.op;
this.currentLitlenTable = litlen;
var olength = output.length;
var code;
var ti;
var codeDist;
var codeLength;
while((code = this.readCodeByTable(litlen)) !== 256) {
if(code < 256) {
if(op >= olength) {
output = this.expandBuffer();
olength = output.length
}
output[op++] = code;
continue
}
ti = code - 257;
codeLength = Zlib.RawInflate.LengthCodeTable[ti];
if(Zlib.RawInflate.LengthExtraTable[ti] > 0) {
codeLength += this.readBits(Zlib.RawInflate.LengthExtraTable[ti])
}
code = this.readCodeByTable(dist);
codeDist = Zlib.RawInflate.DistCodeTable[code];
if(Zlib.RawInflate.DistExtraTable[code] > 0) {
codeDist += this.readBits(Zlib.RawInflate.DistExtraTable[code])
}
if(op + codeLength > olength) {
output = this.expandBuffer();
olength = output.length
}
while(codeLength--) {
output[op] = output[op++ - codeDist]
}
}
while(this.bitsbuflen >= 8) {
this.bitsbuflen -= 8;
this.ip--
}
this.op = op
};
Zlib.RawInflate.prototype.expandBuffer = function(opt_param) {
var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.op - Zlib.RawInflate.MaxBackwardLength);
var backward = this.op - Zlib.RawInflate.MaxBackwardLength;
var i;
var il;
var output = this.output;
if(USE_TYPEDARRAY) {
buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length))
}else {
for(i = 0, il = buffer.length;i < il;++i) {
buffer[i] = output[i + Zlib.RawInflate.MaxBackwardLength]
}
}
this.blocks.push(buffer);
this.totalpos += buffer.length;
if(USE_TYPEDARRAY) {
output.set(output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength))
}else {
for(i = 0;i < Zlib.RawInflate.MaxBackwardLength;++i) {
output[i] = output[backward + i]
}
}
this.op = Zlib.RawInflate.MaxBackwardLength;
return output
};
Zlib.RawInflate.prototype.expandBufferAdaptive = function(opt_param) {
var buffer;
var ratio = this.input.length / this.ip + 1 | 0;
var maxHuffCode;
var newSize;
var maxInflateSize;
var input = this.input;
var output = this.output;
if(opt_param) {
if(typeof opt_param.fixRatio === "number") {
ratio = opt_param.fixRatio
}
if(typeof opt_param.addRatio === "number") {
ratio += opt_param.addRatio
}
}
if(ratio < 2) {
maxHuffCode = (input.length - this.ip) / this.currentLitlenTable[2];
maxInflateSize = maxHuffCode / 2 * 258 | 0;
newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1
}else {
newSize = output.length * ratio
}
if(USE_TYPEDARRAY) {
buffer = new Uint8Array(newSize);
buffer.set(output)
}else {
buffer = output
}
this.output = buffer;
return this.output
};
Zlib.RawInflate.prototype.concatBuffer = function() {
var pos = 0;
var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);
var output = this.output;
var blocks = this.blocks;
var block;
var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);
var i;
var il;
var j;
var jl;
if(blocks.length === 0) {
return USE_TYPEDARRAY ? this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op) : this.output.slice(Zlib.RawInflate.MaxBackwardLength, this.op)
}
for(i = 0, il = blocks.length;i < il;++i) {
block = blocks[i];
for(j = 0, jl = block.length;j < jl;++j) {
buffer[pos++] = block[j]
}
}
for(i = Zlib.RawInflate.MaxBackwardLength, il = this.op;i < il;++i) {
buffer[pos++] = output[i]
}
this.blocks = [];
this.buffer = buffer;
return this.buffer
};
Zlib.RawInflate.prototype.concatBufferDynamic = function() {
var buffer;
var op = this.op;
if(USE_TYPEDARRAY) {
if(this.resize) {
buffer = new Uint8Array(op);
buffer.set(this.output.subarray(0, op))
}else {
buffer = this.output.subarray(0, op)
}
}else {
if(this.output.length > op) {
this.output.length = op
}
buffer = this.output
}
this.buffer = buffer;
return this.buffer
}
});
goog.provide("Zlib.Util");
goog.scope(function() {
Zlib.Util.stringToByteArray = function(str) {
var tmp = str.split("");
var i;
var il;
for(i = 0, il = tmp.length;i < il;i++) {
tmp[i] = (tmp[i].charCodeAt(0) & 255) >>> 0
}
return tmp
}
});
goog.provide("Zlib.Adler32");
goog.require("USE_TYPEDARRAY");
goog.require("Zlib.Util");
goog.scope(function() {
Zlib.Adler32 = function(array) {
if(typeof array === "string") {
array = Zlib.Util.stringToByteArray(array)
}
return Zlib.Adler32.update(1, array)
};
Zlib.Adler32.update = function(adler, array) {
var s1 = adler & 65535;
var s2 = adler >>> 16 & 65535;
var len = array.length;
var tlen;
var i = 0;
while(len > 0) {
tlen = len > Zlib.Adler32.OptimizationParameter ? Zlib.Adler32.OptimizationParameter : len;
len -= tlen;
do {
s1 += array[i++];
s2 += s1
}while(--tlen);
s1 %= 65521;
s2 %= 65521
}
return(s2 << 16 | s1) >>> 0
};
Zlib.Adler32.OptimizationParameter = 1024
});
goog.provide("Zlib.Inflate");
goog.require("USE_TYPEDARRAY");
goog.require("Zlib.Adler32");
goog.require("Zlib.RawInflate");
goog.scope(function() {
Zlib.Inflate = function(input, opt_params) {
var bufferSize;
var bufferType;
var cmf;
var flg;
this.input = input;
this.ip = 0;
this.rawinflate;
this.verify;
if(opt_params || !(opt_params = {})) {
if(opt_params["index"]) {
this.ip = opt_params["index"]
}
if(opt_params["verify"]) {
this.verify = opt_params["verify"]
}
}
cmf = input[this.ip++];
flg = input[this.ip++];
switch(cmf & 15) {
case Zlib.CompressionMethod.DEFLATE:
this.method = Zlib.CompressionMethod.DEFLATE;
break;
default:
throw new Error("unsupported compression method");
}
if(((cmf << 8) + flg) % 31 !== 0) {
throw new Error("invalid fcheck flag:" + ((cmf << 8) + flg) % 31);
}
if(flg & 32) {
throw new Error("fdict flag is not supported");
}
this.rawinflate = new Zlib.RawInflate(input, {"index":this.ip, "bufferSize":opt_params["bufferSize"], "bufferType":opt_params["bufferType"], "resize":opt_params["resize"]})
};
Zlib.Inflate.BufferType = Zlib.RawInflate.BufferType;
Zlib.Inflate.prototype.decompress = function() {
var input = this.input;
var buffer;
var adler32;
buffer = this.rawinflate.decompress();
this.ip = this.rawinflate.ip;
if(this.verify) {
adler32 = (input[this.ip++] << 24 | input[this.ip++] << 16 | input[this.ip++] << 8 | input[this.ip++]) >>> 0;
if(adler32 !== Zlib.Adler32(buffer)) {
throw new Error("invalid adler-32 checksum");
}
}
return buffer
}
});
goog.provide("Zlib");
goog.scope(function() {
Zlib.CompressionMethod = {DEFLATE:8, RESERVED:15}
});
goog.provide("Zlib.Deflate");
goog.require("USE_TYPEDARRAY");
goog.require("Zlib");
goog.require("Zlib.Adler32");
goog.require("Zlib.RawDeflate");
goog.scope(function() {
Zlib.Deflate = function(input, opt_params) {
this.input = input;
this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(Zlib.Deflate.DefaultBufferSize);
this.compressionType = Zlib.Deflate.CompressionType.DYNAMIC;
this.rawDeflate;
var rawDeflateOption = {};
var prop;
if(opt_params || !(opt_params = {})) {
if(typeof opt_params["compressionType"] === "number") {
this.compressionType = opt_params["compressionType"]
}
}
for(prop in opt_params) {
rawDeflateOption[prop] = opt_params[prop]
}
rawDeflateOption["outputBuffer"] = this.output;
this.rawDeflate = new Zlib.RawDeflate(this.input, rawDeflateOption)
};
Zlib.Deflate.DefaultBufferSize = 32768;
Zlib.Deflate.CompressionType = Zlib.RawDeflate.CompressionType;
Zlib.Deflate.compress = function(input, opt_params) {
return(new Zlib.Deflate(input, opt_params)).compress()
};
Zlib.Deflate.prototype.compress = function() {
var cm;
var cinfo;
var cmf;
var flg;
var fcheck;
var fdict;
var flevel;
var clevel;
var adler;
var error = false;
var output;
var pos = 0;
output = this.output;
cm = Zlib.CompressionMethod.DEFLATE;
switch(cm) {
case Zlib.CompressionMethod.DEFLATE:
cinfo = Math.LOG2E * Math.log(Zlib.RawDeflate.WindowSize) - 8;
break;
default:
throw new Error("invalid compression method");
}
cmf = cinfo << 4 | cm;
output[pos++] = cmf;
fdict = 0;
switch(cm) {
case Zlib.CompressionMethod.DEFLATE:
switch(this.compressionType) {
case Zlib.Deflate.CompressionType.NONE:
flevel = 0;
break;
case Zlib.Deflate.CompressionType.FIXED:
flevel = 1;
break;
case Zlib.Deflate.CompressionType.DYNAMIC:
flevel = 2;
break;
default:
throw new Error("unsupported compression type");
}
break;
default:
throw new Error("invalid compression method");
}
flg = flevel << 6 | fdict << 5;
fcheck = 31 - (cmf * 256 + flg) % 31;
flg |= fcheck;
output[pos++] = flg;
adler = Zlib.Adler32(this.input);
this.rawDeflate.op = pos;
output = this.rawDeflate.compress();
pos = output.length;
if(USE_TYPEDARRAY) {
output = new Uint8Array(output.buffer);
if(output.length <= pos + 4) {
this.output = new Uint8Array(output.length + 4);
this.output.set(output);
output = this.output
}
output = output.subarray(0, pos + 4)
}
output[pos++] = adler >> 24 & 255;
output[pos++] = adler >> 16 & 255;
output[pos++] = adler >> 8 & 255;
output[pos++] = adler & 255;
return output
}
});
goog.provide("Zlib.exportObject");
goog.require("Zlib");
goog.scope(function() {
Zlib.exportObject = function(enumString, exportKeyValue) {
var keys;
var key;
var i;
var il;
if(Object.keys) {
keys = Object.keys(exportKeyValue)
}else {
keys = [];
i = 0;
for(key in exportKeyValue) {
keys[i++] = key
}
}
for(i = 0, il = keys.length;i < il;++i) {
key = keys[i];
goog.exportSymbol(enumString + "." + key, exportKeyValue[key])
}
}
});
goog.require("Zlib.Inflate");
goog.require("Zlib.exportObject");
goog.exportSymbol("Zlib.Inflate", Zlib.Inflate);
goog.exportSymbol("Zlib.Inflate.prototype.decompress", Zlib.Inflate.prototype.decompress);
Zlib.exportObject("Zlib.Inflate.BufferType", {"ADAPTIVE":Zlib.Inflate.BufferType.ADAPTIVE, "BLOCK":Zlib.Inflate.BufferType.BLOCK});
goog.require("Zlib.Deflate");
goog.require("Zlib.exportObject");
goog.exportSymbol("Zlib.Deflate", Zlib.Deflate);
goog.exportSymbol("Zlib.Deflate.compress", Zlib.Deflate.compress);
goog.exportSymbol("Zlib.Deflate.prototype.compress", Zlib.Deflate.prototype.compress);
Zlib.exportObject("Zlib.Deflate.CompressionType", {"NONE":Zlib.Deflate.CompressionType.NONE, "FIXED":Zlib.Deflate.CompressionType.FIXED, "DYNAMIC":Zlib.Deflate.CompressionType.DYNAMIC});
}).call(this);

        var WebStorageUtility = (function() {
            var Config = {
                taTimer: 180,
                ntaTimer: 180,
                ntaSwitchTimer: 0,
                ntvSliderTimer: 180,
                ntvSlider: 180,
                overlayTimer: 360,
                BRUID_KEY: 'pmbruid01',
                UID_KEY: 'pmuid01',
                messageSeparator: '#&#',
                keepAliveID: null,
                keepAliveCounter: 0
            };

            var cookieHandler = (function() {
                var getItem = function (sKey) {
                    if(!sKey) {
                        return null;
                    }
                    return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
                };
                var setItem = function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
                    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
                    var sExpires = "";
                    if (vEnd) {
                        switch (vEnd.constructor) {
                            case Number:
                                sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
                                break;
                            case String:
                                sExpires = "; expires=" + vEnd;
                                break;
                            case Date:
                                sExpires = "; expires=" + vEnd.toUTCString();
                                break;
                        }
                    }
                    document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
                    return true;
                };
                var removeItem = function (sKey, sPath, sDomain) {
                    if (!hasItem(sKey)) { return false; }
                    document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
                    return true;
                };
                var hasItem = function (sKey) {
                    if (!sKey) { return false; }
                    return (new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
                };
                var keys = function () {
                    var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
                    for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) { aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); }
                    return aKeys;
                };

                // checks are cookies enabled from navigator object
                // if that doesn't work, it creates a test cookie
                var cookiesEnabled = function() {
                    // Ovo u IE-9 vraca uvijek true?
                    var cookieEnabled = (navigator.cookieEnabled) ? true : false;

                    if(typeof navigator.cookieEnabled == 'undefined' && !cookieEnabled) {
                        document.cookie = 'testcookie';
                        cookieEnabled = (document.cookie.indexOf('testcookie') != -1) ? true : false;
                        removeItem('testcookie');
                    }
                    return cookieEnabled;
                };

                return {
                    get: getItem,
                    set: setItem,
                    remove: removeItem,
                    hasItem: hasItem,
                    keys: keys,
                    isEnabled: cookiesEnabled
                };
            }());

            var makeAttributionConfigRequest = function(params) {
                var paramsObj = JSON.parse(params);

                PostManager.sendGet(paramsObj.url, function(response) {
                    parent.postMessage('ATTRCONFRESP' + Config.messageSeparator + response, '*');
                }, function(){});
            };

            var Messenger = (function() {
                var init = function() {
                    if(typeof document.addEventListener !== 'undefined') {
                        window.addEventListener('message', messageHandler, false);
                    } else {
                        window.attachEvent('onmessage', messageHandler);
                    }
                }

                var messageHandler = function(evt) {
                    var params = evt.data.toString().split(Config.messageSeparator),
                        msg = params[0];

                    try {
                        switch (msg) {
                            case 'GETPMSSCRPRM' :
                                sendSSParams();
                                break;
                            case 'CLEARPMSSCRPRM' :
                                StorageManager.remove('session', 'PMLPI');
                                StorageManager.remove('session', 'PMLP_BRANDED');
                                StorageManager.remove('session', 'FIRSTLP');
                                break;
                            case 'SETPMSSBRANDED' :
                                WindowNameManager.setIsBranded('1');
                                break;
                            case 'SETTRANSTIME' :
                                if(params.length >= 2 && !isNaN(parseInt(params[1]))) {
                                   TimersManager.setWithTimeToLive('TRANS_TIME', params[1]);
                                }else{
                                   TimersManager.set('TRANS_TIME');
                                }
                                break;
                            case 'SETTRANSTIMERWITHTTL' :
                                if(params.length >=2 && params[1] === "") {
                                    params[1] = Config.taTimer;
                                }
                                TimersManager.setTimerWithProlongedTime('TRANS_TIME', params[1]);
                                break;
                            case 'SETDISPTIMERWITHTTL' :
                                if(params.length >=2 && params[1] === "") {
                                    params[1] = Config.ntaTimer;
                                }
                                TimersManager.setTimerWithProlongedTime('DISP_TIME', params[1]);
                                break;
                            case 'SETTADELAY' :
                                if(params.length >= 2 && !isNaN(parseInt(params[1]))) {
                                   TimersManager.setWithTimeToLive('TRANS_DELAY_TIME', params[1]);
                                }
                                break;
                            case 'SETDISPTIME' :
                                 if(params.length >= 2 && !isNaN(parseInt(params[1]))) {
                                    TimersManager.setWithTimeToLive('DISP_TIME', Config.ntaSwitchTimer > 0 ? Config.ntaSwitchTimer : params[1]);
                                 } else {
                                    TimersManager.setWithTimeToLive('DISP_TIME', Config.ntaSwitchTimer > 0 ? Config.ntaSwitchTimer :  Config.ntaTimer);
                                 }
                                break;
                            case 'SETNTATIME' :
                                TimersManager.reSetNTATimer(parseInt(params[1], 10));
                                break;
                            case 'RMVNTATMSWITCH' :
                                TimersManager.removeNTATimerSwitch();
                                break;
                            case 'SETNTVSLIDE' :
                                 if(params.length >= 2 && !isNaN(parseInt(params[1]))) {
                                    TimersManager.setWithTimeToLive('NTVSLIDER_TIME', params[1]);
                                 } else {
                                    TimersManager.set('NTVSLIDER_TIME');
                                 }
                                break;
                            case 'SETNTV' :
                                 if(params.length >= 2 && !isNaN(parseInt(params[1]))) {
                                    TimersManager.setWithTimeToLive('NTV_TIME', params[1]);
                                 } else {
                                    TimersManager.set('NTV_TIME');
                                 }
                                break;
                            case 'SETDISPHVC' :
                                StorageManager.set('local', 'DISP_HVC_CAN_SHOW', 0);
                                break;
                            case 'SETLBXTIME' :
                                 if(params.length >= 2 && !isNaN(parseInt(params[1]))) {
                                    TimersManager.setWithTimeToLive('LBX_TIME', params[1]);
                                 } else {
                                    TimersManager.set('LBX_TIME');
                                 }
                                break;
                            case 'GETUID' :
                                parent.postMessage('UIDRETVAL'+ Config.messageSeparator + UIDManager.getUidCookie() + Config.messageSeparator + UIDManager.getUidStorage(), '*');
                                break;
                            case 'SETUID' :
                                UIDManager.setUID(params[1]);
                                break;
                            case 'SETUIDCOOKIE' :
                                UIDManager.dropCookie(params[1], null);
                                break;
                            case 'SETUIDSTORAGE' :
                                UIDManager.setStorage(Config.UID_KEY, params[1]);
                                break;
                            case 'SENDLUTRACKING' :
                                UIDManager.sendLuTracking(params[1]);
                                break;
                            case 'PMPOSTDT' :
                                PostManager.sendPost(params);
                                break;
                            case 'STOPBRCRPRM' :
                                WindowNameManager.stopBroadcasting();
                                break;
                            case 'SETFIRSTLPVALUE' :
                                StorageManager.set('session', 'FIRSTLP', '0');
                                break;
                            case 'PMATTRCONFREQ' :
                                makeAttributionConfigRequest(params[1]);
                                break;
                            case 'LPCNT' :
                                PostManager.sendPost(params, true);
                                break;
                            case 'BNREPL' :
                                PostManager.sendGet(params[1], sendBackBnReplResponse, function(){});
                                break;
                        }
                    } catch(ex) {}
                }

                var send = function(msg) {
                    parent.postMessage(msg, '*');
                }

                var sendSSParams = function() {
                    var ssParams = WindowNameManager.getParam(),
                        msg = 'PMSSCRPRM01'+ Config.messageSeparator + (ssParams !== null ? (ssParams + Config.messageSeparator + WindowNameManager.getIsBranded() + Config.messageSeparator + WindowNameManager.getIsFirstLp()) : 'EMPTY');

                    send(msg);
                };

                var sendBackBnReplResponse = function(response) {
                    parent.postMessage('BNREPLRESP' + Config.messageSeparator + response, '*');
                };

                return {
                    init: init,
                    send: send
                };
            }());

            var StorageManager = (function() {
                var localEnabled = false,
                    sessionEnabled = false;

                var init = function() {
                    localEnabled = isEnabled('local');
                    sessionEnabled = isEnabled('session');
                };

                var get = function(mode, key) {
                    if(mode === 'local') {
                        if(localEnabled) {
                            return localStorage.getItem(key);
                        } else {
                            return -1;
                        }
                    } else if(mode === 'session') {
                        if(sessionEnabled) {
                            return sessionStorage.getItem(key);
                        } else {
                            return -1;
                        }
                    }
                }

                var set = function(mode, key, value) {
                    if(mode === 'local' && localEnabled) {
                        localStorage.setItem(key, value);
                    } else if(mode === 'session' && sessionEnabled) {
                        sessionStorage.setItem(key, value);
                    }
                }

                var remove = function(mode, key) {
                    if(mode === 'local' && localEnabled) {
                        localStorage.removeItem(key);
                    } else if(mode === 'session' && sessionEnabled) {
                        sessionStorage.removeItem(key);
                    }
                }

                var isEnabled = function(mode) {
                    var mod = 'TEST';
                    try {
                        if(mode === 'local') {
                            localStorage.setItem(mod, mod);
                            localStorage.removeItem(mod);
                            return true;
                        } else if(mode === 'session') {
                            sessionStorage.setItem(mod, mod);
                            sessionStorage.removeItem(mod);
                            return true;
                        }
                    } catch (exception) {
                        return false;
                    }
                };

                var getLocalStatus = function() {
                    return localEnabled;
                }

                var getSessionStatus = function() {
                    return sessionEnabled;
                }

                return {
                    get: get,
                    set: set,
                    remove: remove,
                    localEnabled: getLocalStatus,
                    sessionEnabled: getSessionStatus,
                    init: init
                };
            }());

            var WindowNameManager = (function() {
                var ssParams = null,
                    message = null,
                    reportIntervalID = null,
                    reportIntervalCounter = 0;

                var init = function() {
                    ssParams = StorageManager.get('session', 'PMLPI');
                    message = 'PMSSCRPRM01' + Config.messageSeparator + (ssParams !== null ? (ssParams + Config.messageSeparator + getIsBranded() + Config.messageSeparator + getIsFirstLp()) : 'EMPTY');

                    reportIntervalID = window.setInterval(makeFunction(message), 50);
                }

                var makeFunction = function(message) {
                    return function() {
                        if(reportIntervalCounter > 100) {
                            clearInterval(reportIntervalID);
                        } else {
                            Messenger.send(message);
                            reportIntervalCounter++;
                        }
                    }
                }

                var getParam = function() {
                    return ssParams;
                };

                var getIsBranded = function() {
                    return StorageManager.get('session', 'PMLP_BRANDED');
                };

                var setIsBranded = function(status) {
                    StorageManager.set('session', 'PMLP_BRANDED', status);
                };

                var stopBroadcasting = function() {
                    window.clearInterval(reportIntervalID);
                };

                var getIsFirstLp = function() {
                    var isFirstLP = StorageManager.get('session', 'FIRSTLP');
                    return isFirstLP !== null ? isFirstLP : '1';
                };

                return {
                    init: init,
                    getParam: getParam,
                    getIsBranded: getIsBranded,
                    setIsBranded: setIsBranded,
                    stopBroadcasting: stopBroadcasting,
                    getIsFirstLp: getIsFirstLp
                };
            }());

            var TimersManager = (function() {
                //trans: 'TRANS_TIME',
                //disp: 'DISP_TIME',
                //ntvSlider: 'NTVSLIDER_TIME',
                //ntv: 'NTV_TIME'

                var transCanShow = -1,
                    dispCanShow = -1,
                    ntvSliderCanShow = -1,
                    ntvCanShow = -1,
                    dispHVCCanShow = -1,
                    overlayCanShow = -1,
                    tempTrans = -1,
                    tempDisp = -1,
                    tempNtvSlider = -1,
                    tempNtv = -1,
                    tempDispHVC = -1,
                    tempOverlay = -1,
                    tempTransDelay,
                    changed = false;

                    // not used - maybe remove it
                var canShow = function(timerName, timer) {
                    var timerValue = null;

                    if(!StorageManager.localEnabled()) {
                        return -1;
                    }
                    
                    try {
                        timerValue = StorageManager.get('local', timerName);
                        
                        if(timerValue === null){
                           return 1;
                        }
                        
                        var timerValueArr = timerValue.split(Config.messageSeparator);
                        timerValue = timerValueArr[0];
                        var timeToLive = timerValueArr.length > 1 ? timerValueArr[1] : timer;
                        if((Math.round(new Date().getTime()/1000) - timerValue) > timeToLive) {
                            removeTimer(timerName);
                            if(timerName == 'DISP_TIME') {
                                removeTimer('DISP_HVC_CAN_SHOW');
                            }
                            return 1
                        }

                        return 0;
                    } catch(ex) {
                        return -1;
                    }
                }

                var setTimer = function(timerName) {
                    StorageManager.set('local', timerName, Math.round(new Date().getTime()/1000));
                }

                var setTimerWithTimeToLive = function(timerName, timeToLive) {
                    StorageManager.set('local', timerName, Math.round(new Date().getTime()/1000) + Config.messageSeparator + timeToLive);
                }

                var setTimerWithProlongedTime = function (timerName, ttl) {
                    var isGreater = false,
                        timestamp = Math.floor(new Date().getTime() / 1000),
                        timerFromStorage = StorageManager.get("local", timerName);

                    if(timerFromStorage === null) {
                        isGreater = true;
                    } else {
                        var timerFromStorageArr = timerFromStorage.split(Config.messageSeparator);
                        var timestampFromStorage = parseInt(timerFromStorageArr[0], 10);
                        var ttlFromStorage = parseInt(timerFromStorageArr[1], 10);
                        if(isFinite(timestampFromStorage) && isFinite(ttlFromStorage)
                            && timestampFromStorage <= timestamp && ttlFromStorage < 24 * 60 * 60) {
                            isGreater = timestamp + parseInt(ttl, 10) > timestampFromStorage + ttlFromStorage;
                        } else {
                            isGreater = true;
                        }
                    }
                    if(isGreater) {
                        StorageManager.set("local", timerName, timestamp + Config.messageSeparator + ttl);
                    }
                };

                var removeTimer = function(timerName) {
                    StorageManager.remove('local', timerName);
                }
                var checkTimers = function() {
                    tempTrans = canShow('TRANS_TIME', Config.taTimer);
                    tempTransDelay = canShow('TRANS_DELAY_TIME', 30);
                    tempDisp = canShow('DISP_TIME', Config.ntaTimer);
                    tempNtvSlider = canShow('NTVSLIDER_TIME', Config.ntvSliderTimer);
                    tempNtv = canShow('NTV_TIME', Config.ntvSlider);
                    tempOverlay = canShow("LBX_TIME", Config.overlayTimer);
                    
                    tempTrans = tempTrans & tempTransDelay;
                    
                    if(!StorageManager.localEnabled()) {
                        tempDispHVC = -1;
                    }else{
                        tempDispHVC = StorageManager.get('local', 'DISP_HVC_CAN_SHOW');
                        tempDispHVC = tempDispHVC == null ? 1 : tempDispHVC;
                    }

                    changed = false;
                    
                    if(tempDispHVC !== -1 && dispHVCCanShow !== tempDispHVC) {
                        changed = true;
                        dispHVCCanShow = tempDispHVC;
                    }

                    if(tempTrans !== -1 && transCanShow !== tempTrans) {
                        changed = true;
                        transCanShow = tempTrans;
                    }

                    if(tempDisp !== -1 && dispCanShow !== tempDisp) {
                        changed = true;
                        dispCanShow = tempDisp;
                    }

                    if(tempNtvSlider !== -1 && ntvSliderCanShow !== tempNtvSlider) {
                        changed = true;
                        ntvSliderCanShow = tempNtvSlider;
                    }

                    if(tempNtv !== -1 && ntvCanShow !== tempNtv) {
                        changed = true;
                        ntvCanShow = tempNtv;
                    }

                    if(tempOverlay !== -1 && overlayCanShow !== tempOverlay) {
                        changed = true;
                        overlayCanShow = tempOverlay;
                    }

                    if(changed) {
                        Messenger.send('PMTIMERS' + Config.messageSeparator + transCanShow + Config.messageSeparator + dispCanShow + Config.messageSeparator + ntvSliderCanShow + Config.messageSeparator + ntvCanShow + Config.messageSeparator + dispHVCCanShow + Config.messageSeparator + overlayCanShow);
                    }
                };

                var reSetNTATimer = function(timer) {
                    Config.ntaSwitchTimer = timer;
                    if(!StorageManager.get("local", "NTATIMERSWITCH")) {
                        StorageManager.set("local", "NTATIMERSWITCH", timer);
                    }
                };

                var removeNTATimerSwitch = function() {
                    StorageManager.remove("local", "NTATIMERSWITCH");
                    Config.ntaSwitchTimer = 0;
                    checkTimers();
                };

                var init = function() {
                    // this is added to eliminate initial waiting period of 300ms
                    checkTimers();
                    window.setInterval(checkTimers, 300);
                };

                return {
                    canShow: canShow,
                    set: setTimer,
                    setWithTimeToLive : setTimerWithTimeToLive,
                    setTimerWithProlongedTime: setTimerWithProlongedTime,
                    remove: removeTimer,
                    init: init,
                    reSetNTATimer: reSetNTATimer,
                    removeNTATimerSwitch: removeNTATimerSwitch
                };
            }());

            var UIDManager = (function() {
                var bruidCookie = null,
                    bruidStorage = null,
                    uidCookie = null,
                    uidStorage = null,
                    runned = false;

                var dropCookie = function(uidValue, bruidValue) {
                    if(uidValue) {
                        var img1 = new Image();
                        img1.src = 'https://partners.cmptch.com/suic?u=' + uidValue;
                    }
                    if(bruidValue) {
                        var img2 = new Image();
                        img2.src = 'https://partners.cmptch.com/suic?b=' + bruidValue;
                    }
                };

                var tryParseJSON = function(val) {
                    try {
                        return JSON.parse(val);
                    } catch (ex) {
                        return false;
                    }
                };

                var setStorage = function(key, browserId) {
                    StorageManager.set('local', key, browserId);
                };

                var setUID = function(value) {
                    StorageManager.set('local', Config.UID_KEY, value);
                    dropCookie(value, null);
                };

                var getUidCookie = function() {
                    return uidCookie;
                };

                var getUidStorage = function() {
                    return uidStorage;
                };

                var luResponseHandler = function(responseText) {
                    var respJSON = tryParseJSON(responseText);

                    if(respJSON) {
                        if(respJSON.uid) {
                            setUID(respJSON.uid);
                        }
                        parent.postMessage('PMLURSP' + Config.messageSeparator + responseText, '*');
                    } else {
                        parent.postMessage('PMPSTRSP' + Config.messageSeparator + responseText, '*');
                    }
                };

                var sendLuTracking = function(url){
				    var xhr = new XMLHttpRequest();
                    try {
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
                                luResponseHandler(this.responseText);
                            }
                        };
                        xhr.open("GET",url,true);
                        xhr.withCredentials = true;
                        xhr.send();
					} catch(ex) {}
               };

                var run = function() {
                    var tempUidCookie = null,
                        tempUidStorage = null,
                        reportIntervalID = null,
                        reportIntervalCounter = 0;

                    if(runned) {
                        return;
                    } else {
                        runned = true;
                    }

                    if(cookieHandler.isEnabled()) {
                        tempUidCookie = cookieHandler.get(Config.UID_KEY);

                        if(cookieHandler.hasItem(Config.UID_KEY) && typeof tempUidCookie !== 'undefined' && tempUidCookie !== null) {
                            uidCookie = tempUidCookie;
                        }
                    }

                    if(StorageManager.localEnabled()) {
                        tempUidStorage = StorageManager.get('local', Config.UID_KEY);

                        if(typeof tempUidStorage !== 'undefined' && tempUidStorage !== null && tempUidStorage !== 'null') {
                            uidStorage = tempUidStorage;
                        }
                    }

                    reportIntervalID = window.setInterval(function() {
                        if(reportIntervalCounter > 150) {
                            clearInterval(reportIntervalID);
                        } else {
                            parent.postMessage('PMUIDVAL' + Config.messageSeparator + uidCookie + Config.messageSeparator + uidStorage, '*');
                            reportIntervalCounter++;
                        }
                    }, 50);
                };

                return {
                    dropCookie: dropCookie,
                    setStorage: setStorage,
                    setUID: setUID,
                    getUidCookie: getUidCookie,
                    getUidStorage: getUidStorage,
                    sendLuTracking: sendLuTracking,
                    run: run
                };
            }());

            var PostManager = (function() {
                var str2ba = function (str, unkwn) {
                   //pretvara string u niz bajtova po Windows-1252 charset-u
                   var buf = new Uint8Array(str.length);
                   for (var i = 0, strLen = str.length; i < strLen; i++) {
                      var charCode = str.charCodeAt(i);
                      if (charCode > 255) {
                         switch (charCode) {
                            case 0x20AC: charCode = 0x80; break;
                            case 0x201A: charCode = 0x82; break;
                            case 0x0192: charCode = 0x83; break;
                            case 0x201E: charCode = 0x84; break;
                            case 0x2026: charCode = 0x85; break;
                            case 0x2020: charCode = 0x86; break;
                            case 0x2021: charCode = 0x87; break;
                            case 0x02C6: charCode = 0x88; break;
                            case 0x2030: charCode = 0x89; break;
                            case 0x0160: charCode = 0x8a; break;
                            case 0x2039: charCode = 0x8b; break;
                            case 0x0152: charCode = 0x8c; break;
                            case 0x017D: charCode = 0x8e; break;
                            case 0x2018: charCode = 0x91; break;
                            case 0x2019: charCode = 0x92; break;
                            case 0x201C: charCode = 0x93; break;
                            case 0x201D: charCode = 0x94; break;
                            case 0x2022: charCode = 0x95; break;
                            case 0x2013: charCode = 0x96; break;
                            case 0x2014: charCode = 0x97; break;
                            case 0x02DC: charCode = 0x98; break;
                            case 0x2122: charCode = 0x99; break;
                            case 0x0161: charCode = 0x9a; break;
                            case 0x203A: charCode = 0x9b; break;
                            case 0x0153: charCode = 0x9c; break;
                            case 0x017E: charCode = 0x9e; break;
                            case 0x0178: charCode = 0x9f; break;
                            default: charCode = unkwn;
                         }
                      }
                      buf[i] = charCode;
                   }
                   return buf;
                };

                var sendPost = function(dataArr, isLPPost) {
                    var keywordsBytes = null,
                        keywordsBytesCompressed = null,
                        postData = null,
                        postParamsObj = null;

                    try {
                        if(!dataArr) {
                            return;
                        }

                        postData = dataArr.length > 2 ? dataArr.slice(1, dataArr.length).join(Config.messageSeparator) : dataArr[1];
                        postParamsObj = JSON.parse(postData);
                        if(isLPPost) {
                            keywordsBytes = str2ba(postParamsObj.data, "?".charCodeAt(0));
                        } else {
                            keywordsBytes = str2ba(JSON.stringify(postParamsObj.data), "?".charCodeAt(0));
                        }
                        keywordsBytesCompressed = Zlib.Deflate.compress(keywordsBytes);

                        if(isLPPost) {
                            makePost(postParamsObj.url, keywordsBytesCompressed);
                        } else {
                            makePost(postParamsObj.url, keywordsBytesCompressed, function(payload) {
                                parent.postMessage('PMPSTRSP' + Config.messageSeparator + payload, '*');
                            });
                        }
                    } catch(ex) {}
                };

                var makePost = function(url, postContent, successCallback) {
                    var xhr = new XMLHttpRequest();

                    try {
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState == XMLHttpRequest.DONE) {
                                if(xhr.status == 200) {
                                    if(typeof successCallback === "function") {
                                        successCallback(this.responseText);
                                    }
                                } else if(xhr.status == 400) {
                                    //console.log('There was an error 400')
                                } else {
                                    //console.log('something else other than 200 was returned')
                                }
                            }
                        }

                        xhr.open("POST",url,true);
                        xhr.withCredentials = true;
                        xhr.send(postContent);
                    } catch(ex) {}
                };

                var sendGet = function(url, succesCallback, errorCallback) {
                    var xhr = new XMLHttpRequest();

                    try {
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState == XMLHttpRequest.DONE) {
                                if (xhr.status == 200) {
                                    succesCallback(this.responseText);
                                } else if (xhr.status == 400) {
                                    errorCallback()
                                } else {
                                    //console.log('something else other than 200 was returned')
                                }
                            }
                        };

                        xhr.open("GET", url, true);
                        xhr.withCredentials = true;
                        xhr.send();
                    } catch (ex) {}
                };

                return {
                    sendPost: sendPost,
                    sendGet: sendGet
                };
            }());

            var getConfigParams = function() {
                var urlParams = document.location.href.split('#&#');
                    if(urlParams.length > 1) {
                        Config.taTimer = parseInt(urlParams[1], 10);
                        Config.ntaTimer = parseInt(urlParams[2], 10);
                        Config.overlayTimer = parseInt(urlParams[3], 10);
                    }
            };

            var checkNTATimerSwitch = function() {
                var ntaTimerSwitch = StorageManager.get('local', 'NTATIMERSWITCH');
                if(ntaTimerSwitch) {
                    Config.ntaTimer = parseInt(ntaTimerSwitch, 10);
                }
            };

            var sendBeacon = function() {
                parent.postMessage('MNGFRMRD', '*');
                Config.keepAliveID = window.setInterval(function() {
                    if(Config.keepAliveCounter < 40) {
                        Config.keepAliveCounter++;
                        parent.postMessage('MNGFRMRD', '*');
                    } else {
                        window.clearInterval(Config.keepAliveID);
                    }
                }, 250);
            };

            var init = function() {
                getConfigParams();
                StorageManager.init();
                Messenger.init();
                UIDManager.run();
                WindowNameManager.init();
                TimersManager.init();
                sendBeacon();

                checkNTATimerSwitch();
            };

            return {
                init: init
            };
        }()).init();
    </script>
</head>
<body marginwidth="0" marginheight="0">
</body></html>